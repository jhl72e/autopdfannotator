<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DrawingLayer Implementation Test</title>
  <style>
    body {
      font-family: system-ui, -apple-system, sans-serif;
      margin: 20px;
      background: #f3f4f6;
    }
    h1 {
      color: #1f2937;
    }
    .test-section {
      background: white;
      padding: 20px;
      margin: 20px 0;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .test-result {
      padding: 10px;
      margin: 10px 0;
      border-radius: 4px;
      font-family: monospace;
    }
    .test-result.pass {
      background: #d1fae5;
      color: #065f46;
      border-left: 4px solid #10b981;
    }
    .test-result.fail {
      background: #fee2e2;
      color: #991b1b;
      border-left: 4px solid #ef4444;
    }
    #test-container {
      width: 800px;
      height: 600px;
      position: relative;
      border: 2px solid #d1d5db;
      background: white;
      margin: 20px 0;
    }
    .controls {
      margin: 20px 0;
    }
    button {
      background: #3b82f6;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      margin-right: 10px;
    }
    button:hover {
      background: #2563eb;
    }
    button:active {
      background: #1d4ed8;
    }
    .status {
      padding: 10px;
      background: #f3f4f6;
      border-radius: 4px;
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <h1>DrawingLayer Implementation Test</h1>
  <p>Testing Step 4 implementation: Converting DrawingLayer.jsx to DrawingLayer.js</p>

  <!-- Unit Tests -->
  <div class="test-section">
    <h2>Unit Tests</h2>
    <div id="unit-test-results"></div>
  </div>

  <!-- Visual Test Container -->
  <div class="test-section">
    <h2>Visual Tests</h2>
    <div class="controls">
      <button onclick="testSimpleArrow()">Test 1: Simple Arrow</button>
      <button onclick="testMultiStrokeDiagram()">Test 2: Multi-Stroke Diagram</button>
      <button onclick="testAIDiagram()">Test 3: AI-Generated Tree</button>
      <button onclick="testComplexAnimation()">Test 4: Complex Animation</button>
      <button onclick="testViewportResize()">Test 5: Viewport Resize</button>
      <button onclick="cleanupTest()">Cleanup</button>
    </div>
    <div class="status" id="status">Ready. Click a test button to start.</div>
    <div id="test-container"></div>
  </div>

  <script type="module">
    import BaseLayer from '../src/layers/BaseLayer.js';
    import DrawingLayer from '../src/layers/DrawingLayer.js';

    const resultsContainer = document.getElementById('unit-test-results');
    const statusDiv = document.getElementById('status');
    let currentLayer = null;
    let animationInterval = null;

    // Helper function to display test results
    function logTest(testName, passed, message = '') {
      const div = document.createElement('div');
      div.className = `test-result ${passed ? 'pass' : 'fail'}`;
      div.textContent = `${passed ? '✓' : '✗'} ${testName}${message ? ': ' + message : ''}`;
      resultsContainer.appendChild(div);
      return passed;
    }

    // Helper function to update status
    function updateStatus(message) {
      statusDiv.textContent = message;
    }

    // Run unit tests
    function runUnitTests() {
      resultsContainer.innerHTML = '<h3>Running Unit Tests...</h3>';

      const container = document.getElementById('test-container');
      const viewport = { width: 800, height: 600, scale: 1.0 };

      // Test 1: Instantiation
      try {
        const layer = new DrawingLayer(container, viewport);
        logTest('Test 1.1: DrawingLayer instantiates', true);
        logTest('Test 1.2: Extends BaseLayer', layer instanceof BaseLayer);
        logTest('Test 1.3: Creates canvas element', layer.canvasElement instanceof HTMLCanvasElement);
        logTest('Test 1.4: Canvas has correct zIndex', layer.canvasElement.style.zIndex === '40');
        logTest('Test 1.5: Canvas has correct position', layer.canvasElement.style.position === 'absolute');
        logTest('Test 1.6: Context is created', layer.ctx !== null && layer.ctx instanceof CanvasRenderingContext2D);
        logTest('Test 1.7: RAF ID initialized to null', layer.rafId === null);

        // Test 2: Canvas Setup with DPR
        const dpr = window.devicePixelRatio || 1;
        const expectedWidth = Math.round(viewport.width * dpr);
        const expectedHeight = Math.round(viewport.height * dpr);
        logTest('Test 2.1: Canvas buffer width correct', layer.canvasElement.width === expectedWidth,
          `Expected ${expectedWidth}, got ${layer.canvasElement.width}`);
        logTest('Test 2.2: Canvas buffer height correct', layer.canvasElement.height === expectedHeight,
          `Expected ${expectedHeight}, got ${layer.canvasElement.height}`);
        logTest('Test 2.3: Canvas display width correct', layer.canvasElement.style.width === '800px');
        logTest('Test 2.4: Canvas display height correct', layer.canvasElement.style.height === '600px');

        // Test 3: setAnnotations
        const annotations = [{
          id: 'test-1',
          type: 'ink',
          page: 1,
          start: 0,
          end: 2,
          strokes: [{
            color: '#ff0000',
            size: 5,
            points: [
              { x: 0.1, y: 0.1, t: 0 },
              { x: 0.5, y: 0.5, t: 1 }
            ]
          }]
        }];
        layer.setAnnotations(annotations);
        logTest('Test 3.1: setAnnotations stores annotations', layer.annotations.length === 1);
        logTest('Test 3.2: Annotation data preserved', layer.annotations[0].id === 'test-1');

        // Test 4: setViewport
        const newViewport = { width: 1000, height: 800, scale: 1.5 };
        layer.setViewport(newViewport);
        logTest('Test 4.1: setViewport updates viewport', layer.viewport.width === 1000);
        logTest('Test 4.2: Canvas buffer resized', layer.canvasElement.width === Math.round(1000 * dpr));
        logTest('Test 4.3: Canvas display resized', layer.canvasElement.style.width === '1000px');

        // Test 5: updateTime
        layer.updateTime(0.5);
        logTest('Test 5.1: updateTime updates currentTime', layer.currentTime === 0.5);
        logTest('Test 5.2: RAF loop started', layer.rafId !== null);

        // Test 6: render and update methods exist
        logTest('Test 6.1: render method exists', typeof layer.render === 'function');
        logTest('Test 6.2: update method exists', typeof layer.update === 'function');
        layer.render(); // Should not throw
        layer.update(); // Should not throw
        logTest('Test 6.3: render executes without error', true);
        logTest('Test 6.4: update executes without error', true);

        // Test 7: destroy
        layer.destroy();
        logTest('Test 7.1: RAF canceled after destroy', layer.rafId === null);
        logTest('Test 7.2: Context cleared after destroy', layer.ctx === null);
        logTest('Test 7.3: Canvas element cleared after destroy', layer.canvasElement === null);
        logTest('Test 7.4: isDestroyed flag set', layer.isDestroyed === true);

        // Test 8: Error handling after destroy
        try {
          layer.setAnnotations([]);
          logTest('Test 8.1: Methods throw after destroy', false, 'Should have thrown error');
        } catch (e) {
          logTest('Test 8.1: Methods throw after destroy', e.message.includes('destroyed'));
        }

        resultsContainer.innerHTML += '<h3>✓ All Unit Tests Completed</h3>';

      } catch (error) {
        logTest('Unit Tests', false, error.message);
        console.error('Unit test error:', error);
      }
    }

    // Visual Test 1: Simple Arrow
    window.testSimpleArrow = function() {
      cleanupTest();
      updateStatus('Test 1: Drawing simple arrow with progressive animation...');

      const container = document.getElementById('test-container');
      const viewport = { width: 800, height: 600, scale: 1.0 };
      currentLayer = new DrawingLayer(container, viewport);

      const annotation = {
        id: 'arrow-1',
        type: 'ink',
        page: 1,
        start: 0,
        end: 3,
        strokes: [{
          color: '#3b82f6',
          size: 4,
          points: [
            { x: 0.2, y: 0.5, t: 0 },
            { x: 0.7, y: 0.5, t: 2 },
            { x: 0.65, y: 0.48, t: 2.3 },
            { x: 0.7, y: 0.5, t: 2.5 },
            { x: 0.65, y: 0.52, t: 2.8 }
          ]
        }]
      };

      currentLayer.setAnnotations([annotation]);
      currentLayer.render();

      // Animate
      let time = 0;
      animationInterval = setInterval(() => {
        time += 0.05;
        currentLayer.updateTime(time);
        if (time > 4) {
          updateStatus('Test 1: Complete! Arrow should persist on screen.');
          clearInterval(animationInterval);
        }
      }, 50);
    };

    // Visual Test 2: Multi-Stroke Diagram
    window.testMultiStrokeDiagram = function() {
      cleanupTest();
      updateStatus('Test 2: Drawing multi-stroke box diagram...');

      const container = document.getElementById('test-container');
      const viewport = { width: 800, height: 600, scale: 1.0 };
      currentLayer = new DrawingLayer(container, viewport);

      const annotation = {
        id: 'box-1',
        type: 'ink',
        page: 1,
        start: 0,
        end: 5,
        strokes: [
          // Box outline (4 strokes)
          { color: '#3b82f6', size: 3, points: [
            { x: 0.3, y: 0.3, t: 0 },
            { x: 0.6, y: 0.3, t: 0.5 }
          ]},
          { color: '#3b82f6', size: 3, points: [
            { x: 0.6, y: 0.3, t: 0.5 },
            { x: 0.6, y: 0.5, t: 1.0 }
          ]},
          { color: '#3b82f6', size: 3, points: [
            { x: 0.6, y: 0.5, t: 1.0 },
            { x: 0.3, y: 0.5, t: 1.5 }
          ]},
          { color: '#3b82f6', size: 3, points: [
            { x: 0.3, y: 0.5, t: 1.5 },
            { x: 0.3, y: 0.3, t: 2.0 }
          ]},
          // Diagonal cross (2 strokes)
          { color: '#ef4444', size: 2, points: [
            { x: 0.3, y: 0.3, t: 2.5 },
            { x: 0.6, y: 0.5, t: 3.5 }
          ]},
          { color: '#ef4444', size: 2, points: [
            { x: 0.6, y: 0.3, t: 3.5 },
            { x: 0.3, y: 0.5, t: 4.5 }
          ]}
        ]
      };

      currentLayer.setAnnotations([annotation]);
      currentLayer.render();

      // Animate
      let time = 0;
      animationInterval = setInterval(() => {
        time += 0.05;
        currentLayer.updateTime(time);
        if (time > 6) {
          updateStatus('Test 2: Complete! Box with cross should be visible.');
          clearInterval(animationInterval);
        }
      }, 50);
    };

    // Visual Test 3: AI-Generated Tree Diagram
    window.testAIDiagram = function() {
      cleanupTest();
      updateStatus('Test 3: Drawing AI-generated binary tree diagram...');

      const container = document.getElementById('test-container');
      const viewport = { width: 800, height: 600, scale: 1.0 };
      currentLayer = new DrawingLayer(container, viewport);

      // Helper to generate circle points
      function generateCircle(cx, cy, radius, tStart, tEnd) {
        const points = [];
        const steps = 30;
        const timeStep = (tEnd - tStart) / steps;
        for (let i = 0; i <= steps; i++) {
          const angle = (i / steps) * Math.PI * 2;
          points.push({
            x: cx + radius * Math.cos(angle),
            y: cy + radius * Math.sin(angle),
            t: tStart + (i * timeStep)
          });
        }
        return points;
      }

      const annotation = {
        id: 'tree-1',
        type: 'ink',
        page: 1,
        start: 0,
        end: 8,
        strokes: [
          // Root node
          { color: '#3b82f6', size: 3, points: generateCircle(0.5, 0.2, 0.04, 0, 1) },
          // Left branch
          { color: '#3b82f6', size: 2, points: [
            { x: 0.48, y: 0.24, t: 1 },
            { x: 0.35, y: 0.35, t: 1.5 }
          ]},
          // Left child node
          { color: '#3b82f6', size: 3, points: generateCircle(0.35, 0.38, 0.04, 1.5, 2.5) },
          // Right branch
          { color: '#3b82f6', size: 2, points: [
            { x: 0.52, y: 0.24, t: 2.5 },
            { x: 0.65, y: 0.35, t: 3 }
          ]},
          // Right child node
          { color: '#3b82f6', size: 3, points: generateCircle(0.65, 0.38, 0.04, 3, 4) },
          // Left-left branch
          { color: '#10b981', size: 2, points: [
            { x: 0.33, y: 0.42, t: 4 },
            { x: 0.25, y: 0.53, t: 4.5 }
          ]},
          // Left-left node
          { color: '#10b981', size: 3, points: generateCircle(0.25, 0.56, 0.04, 4.5, 5.5) },
          // Right-right branch
          { color: '#10b981', size: 2, points: [
            { x: 0.67, y: 0.42, t: 5.5 },
            { x: 0.75, y: 0.53, t: 6 }
          ]},
          // Right-right node
          { color: '#10b981', size: 3, points: generateCircle(0.75, 0.56, 0.04, 6, 7) }
        ]
      };

      currentLayer.setAnnotations([annotation]);
      currentLayer.render();

      // Animate
      let time = 0;
      animationInterval = setInterval(() => {
        time += 0.05;
        currentLayer.updateTime(time);
        if (time > 8.5) {
          updateStatus('Test 3: Complete! Binary tree diagram should be visible.');
          clearInterval(animationInterval);
        }
      }, 50);
    };

    // Visual Test 4: Complex Animation with Multiple Annotations
    window.testComplexAnimation = function() {
      cleanupTest();
      updateStatus('Test 4: Multiple overlapping ink annotations...');

      const container = document.getElementById('test-container');
      const viewport = { width: 800, height: 600, scale: 1.0 };
      currentLayer = new DrawingLayer(container, viewport);

      const annotations = [
        // Annotation 1: Blue spiral
        {
          id: 'spiral-1',
          type: 'ink',
          page: 1,
          start: 0,
          end: 3,
          strokes: [{
            color: '#3b82f6',
            size: 3,
            points: Array.from({ length: 50 }, (_, i) => {
              const angle = (i / 50) * Math.PI * 4;
              const radius = 0.1 + (i / 50) * 0.15;
              return {
                x: 0.3 + radius * Math.cos(angle),
                y: 0.3 + radius * Math.sin(angle),
                t: (i / 50) * 3
              };
            })
          }]
        },
        // Annotation 2: Red square (starts after spiral)
        {
          id: 'square-1',
          type: 'ink',
          page: 1,
          start: 3,
          end: 5,
          strokes: [
            { color: '#ef4444', size: 4, points: [
              { x: 0.55, y: 0.2, t: 0 },
              { x: 0.75, y: 0.2, t: 0.5 }
            ]},
            { color: '#ef4444', size: 4, points: [
              { x: 0.75, y: 0.2, t: 0.5 },
              { x: 0.75, y: 0.4, t: 1 }
            ]},
            { color: '#ef4444', size: 4, points: [
              { x: 0.75, y: 0.4, t: 1 },
              { x: 0.55, y: 0.4, t: 1.5 }
            ]},
            { color: '#ef4444', size: 4, points: [
              { x: 0.55, y: 0.4, t: 1.5 },
              { x: 0.55, y: 0.2, t: 2 }
            ]}
          ]
        }
      ];

      currentLayer.setAnnotations(annotations);
      currentLayer.render();

      // Animate
      let time = 0;
      animationInterval = setInterval(() => {
        time += 0.05;
        currentLayer.updateTime(time);
        if (time > 6) {
          updateStatus('Test 4: Complete! Spiral and square should both be visible.');
          clearInterval(animationInterval);
        }
      }, 50);
    };

    // Visual Test 5: Viewport Resize
    window.testViewportResize = function() {
      cleanupTest();
      updateStatus('Test 5: Testing viewport resize functionality...');

      const container = document.getElementById('test-container');
      let viewport = { width: 800, height: 600, scale: 1.0 };
      currentLayer = new DrawingLayer(container, viewport);

      const annotation = {
        id: 'resize-test',
        type: 'ink',
        page: 1,
        start: 0,
        end: 2,
        strokes: [{
          color: '#8b5cf6',
          size: 5,
          points: [
            { x: 0.1, y: 0.1, t: 0 },
            { x: 0.9, y: 0.1, t: 0.5 },
            { x: 0.9, y: 0.9, t: 1 },
            { x: 0.1, y: 0.9, t: 1.5 },
            { x: 0.1, y: 0.1, t: 2 }
          ]
        }]
      };

      currentLayer.setAnnotations([annotation]);
      currentLayer.render();
      currentLayer.updateTime(2); // Show complete drawing

      // Resize viewport after 1 second
      setTimeout(() => {
        updateStatus('Test 5: Resizing viewport to 600x400...');
        container.style.width = '600px';
        container.style.height = '400px';
        viewport = { width: 600, height: 400, scale: 1.0 };
        currentLayer.setViewport(viewport);
        currentLayer.updateTime(2); // Redraw at new size

        setTimeout(() => {
          updateStatus('Test 5: Complete! Drawing should adapt to new viewport size.');
        }, 1000);
      }, 1000);
    };

    // Cleanup function
    window.cleanupTest = function() {
      if (animationInterval) {
        clearInterval(animationInterval);
        animationInterval = null;
      }
      if (currentLayer) {
        currentLayer.destroy();
        currentLayer = null;
      }
      const container = document.getElementById('test-container');
      container.innerHTML = '';
      container.style.width = '800px';
      container.style.height = '600px';
      updateStatus('Cleaned up. Ready for next test.');
    };

    // Run unit tests on page load
    runUnitTests();
  </script>
</body>
</html>
